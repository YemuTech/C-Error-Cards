#### 🔢 **错误 5：混淆头插法和尾插法的内存链接**

**❌ 错误理解**：

- 认为头插法可以用`L->next = s`（实际会破坏链表结构）。
- 尾插法忘记更新尾指针`r`，导致每次插入都遍历链表。

**✅ 内存操作对比**：

| **操作**     | 头插法                | 尾插法                |
| :----------- | :-------------------- | :-------------------- |
| **核心代码** | `s->next = L; L = s;` | `r->next = s; r = s;` |
| **顺序**     | 逆序                  | 正序                  |
| **关键指针** | 只需头指针`L`         | 需头指针`L`+尾指针`r` |

------

### 📚 **终极记忆口诀**

1. **宏定义**：

	> "`#define` 像剪刀✂️，分号一加就糟糕！"

2. **链表操作**：

	> "头插动头`L`，尾插动尾`r`，中间插入玩`next`！"

3. **动态内存**：

	> "`malloc` 之后先判空，用完一定要`free`！"

------

### 🛠️ **测试你的理解**

c

复制

```
// 以下代码的问题是什么？
LinkList CreateList_Wrong(int* arr, int n) {
    LinkList L = NULL;
    for (int i = 0; i < n; i++) {
        LNode* s = (LNode*)malloc(sizeof(LNode));
        s->data = arr[i];
        L->next = s;  // ❌ 致命错误！
    }
    return L;
}
```

**答案**：

- 当`L`为`NULL`时，`L->next`会引发**段错误**。
- 即使`L`非空，此写法也无法正确构建链表（头指针永远指向NULL）。

------

保存这张卡片，链表操作再也不踩坑！ 🚀